<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>地域タイル 47 | JK1JAD</title>
<style>
  :root{
    --ink:#0b132b;   /* 背景 濃紺（JAD標準） */
    --mut:#94a3b8;   /* サブテキスト */
    --y:#d6c420;     /* 強調（黄） */
    --tile:#111827;  /* タイル塗り */
    --tile-stroke:#1f2937;
    --tile-hover:#2a9d8f; /* ホバー色 */
    --label:#e5e7eb;
  }
  html,body{background:#0b132b;margin:0}
  .wrap{max-width:1100px;margin:0 auto;padding:24px 16px;color:#e5e7eb;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif}
  h1{font-size:1.6rem;margin:.2rem 0 .8rem}
  .lead{color:var(--mut)}
/* --- SVG タイルの見た目 --- */
svg{display:block;width:100%;height:auto;background:transparent}
.tile{fill:var(--tile);stroke:var(--tile-stroke);stroke-width:2;rx:10;ry:10;transition:transform .08s ease}
.tile:hover{fill:var(--tile-hover);cursor:pointer;transform:translateY(-2px)}

.label{
  font-size:20px;           /* 全国共通：県名 */
  font-weight:bold;
  fill:var(--label);
  pointer-events:none;
  text-anchor:middle;
  dominant-baseline:middle;
}
.code{
  font-size:20px;           /* 全国共通：数字 */
  font-weight:bold;
  fill:#a3a3a3;
  pointer-events:none;
  text-anchor:middle;
  dominant-baseline:hanging;
}

/* ===================== */
/* 例の色分けはそのまま */
/* ===================== */

/* ▼ 不要なので削除しました
[data-code="01"] .tile{fill:#3b82f6} 
[data-code="47"] .tile{fill:#f97316} 
*/

/* ===================== */
/* SVG全体のスタイル     */
/* ===================== */
svg {
  display: block;
  width: 100%;
  height: auto;
  background: transparent;
}

.tile {
  fill: var(--tile);
  stroke: var(--tile-stroke);
  stroke-width: 2;
  rx: 10;
  ry: 10;
  transition: transform .08s ease;
}

.tile:hover {
  fill: var(--tile-hover);
  cursor: pointer;
  transform: translateY(-2px);
}

/* ===================== */
/* 全国共通: タイル内の文字 */
/* ===================== */
.label {
  font-size: 20px;
  font-weight: bold;
}
  svg{display:block;width:100%;height:auto;background:transparent}
  .tile{fill:var(--tile);stroke:var(--tile-stroke);stroke-width:2;rx:10;ry:10;transition:transform .08s ease}
  .tile:hover{fill:var(--tile-hover);cursor:pointer;transform:translateY(-2px)}


  /* data-code で色分け例（必要に応じて追記） */
/* 全国共通：タイル内の文字を大きく */
.label {
  font-size: 20px;
  font-weight: bold;
}

.code {
  font-size: 20px;
  font-weight: bold;
}

/* 北海道だけタイルを中央から1.2倍に拡大 */
#pref-01 {
  transform: scale(1.2);
}
#tooltip {
  position: fixed;        /* マウス座標に追従 */
  padding: 6px 10px;
  background: rgba(0,0,0,.85);
  color: #fff;
  border-radius: 6px;
  font-size: 14px;
  line-height: 1.2;
  pointer-events: none;   /* マウス操作に干渉しない */
  opacity: 0;
  transform: translateY(-6px);
  transition: opacity .15s ease, transform .15s ease;
  z-index: 9999;
}
#tooltip.show {
  opacity: 1;
  transform: translateY(-10px);
}

</style>
</head>
<body>
<div class="wrap">
  <h1>地域タイル・マップ（47都道府県 / id・data-code 付）</h1>
  <p class="lead">四角タイルを日本列島の感覚配置に。各県は <code>id="pref-XX"</code> / <code>data-code="XX"</code> を持ち、CSS/JSで自由にスタイリング＆インタラクション可能。</p>

  <!-- 可変レイアウトSVG：JSでタイルを生成 -->
  <svg id="jp-tiles" viewBox="0 0 1000 760" aria-label="Japan Prefecture Tiles"></svg>
<div id="tooltip" hidden></div>
  
  <p class="lead" style="margin-top:1rem">使い方：<br>
    1) 値を塗りたい → JS側の <code>values</code> マップに { "13": 72, ... } のように入れて、クラス付与や fill を変更。<br>
    2) クリック遷移 → 下の <code>onTileClick</code> を好きなリンクに変更。<br>
    3) 県ごとに色固定 → CSSの <code>[data-code="XX"]</code> で上書きOK。</p>
</div>

<script>
// ===== 県データ（重なり解消済み配置） =====
const PREFS = [
  // 北海道・東北
  {code:"01",name:"北海道", row:-1, col:9},
  {code:"02",name:"青森",   row:1, col:7},
  {code:"03",name:"岩手",   row:2, col:7},
  {code:"05",name:"秋田",   row:2, col:6},
  {code:"04",name:"宮城",   row:3, col:7},
  {code:"06",name:"山形",   row:3, col:6},
  {code:"07",name:"福島",   row:4, col:7},

  // 関東
  {code:"08",name:"茨城",   row:5, col:7},
  {code:"09",name:"栃木",   row:4, col:6},
  {code:"10",name:"群馬",   row:4, col:5},
  {code:"11",name:"埼玉",   row:5, col:6},
  {code:"12",name:"千葉",   row:6, col:7},
  {code:"13",name:"東京",   row:6, col:6},
  {code:"14",name:"神奈川", row:7, col:6},

  // 中部（北陸・甲信越・東海）
  {code:"15",name:"新潟",   row:3, col:5},
  {code:"16",name:"富山",   row:4, col:4},
  {code:"17",name:"石川",   row:4, col:3},
  {code:"18",name:"福井",   row:5, col:3}, // ← 京都と被らない位置
  {code:"19",name:"山梨",   row:6, col:5},
  {code:"20",name:"長野",   row:5, col:5},
  {code:"21",name:"岐阜",   row:5, col:4},
  {code:"23",name:"愛知",   row:6, col:4},
  {code:"22",name:"静岡",   row:7, col:5}, // ← 山梨と被らない位置

  // 近畿
  {code:"25",name:"滋賀",   row:6, col:3},
  {code:"26",name:"京都",   row:6, col:2},
  {code:"27",name:"大阪",   row:7, col:2},
  {code:"28",name:"兵庫",   row:6, col:1},
  {code:"24",name:"三重",   row:7, col:4},
  {code:"29",name:"奈良",   row:7, col:3},
  {code:"30",name:"和歌山", row:8, col:3},

  // 中国
  {code:"31",name:"鳥取",   row:6, col:0},
  {code:"32",name:"島根",   row:6, col:-1},
  {code:"33",name:"岡山",   row:7, col:0},
  {code:"34",name:"広島",   row:7, col:-1},
  {code:"35",name:"山口",   row:7, col:-2},

  // 四国
  {code:"37",name:"香川",   row:9, col:0},
  {code:"36",name:"徳島",   row:9, col:1},
  {code:"38",name:"愛媛",   row:9, col:-1},
  {code:"39",name:"高知",   row:10, col:0},

  // 九州
  {code:"40",name:"福岡",   row:8, col:-3},
  {code:"41",name:"佐賀",   row:8, col:-4},
  {code:"42",name:"長崎",   row:8, col:-5},
  {code:"43",name:"熊本",   row:9, col:-4},
  {code:"44",name:"大分",   row:9, col:-3},
  {code:"45",name:"宮崎",   row:10, col:-3},
  {code:"46",name:"鹿児島", row:10,col:-4},

  // 沖縄
  {code:"47",name:"沖縄",   row:11,col:-6},
];
// ===== 県データを公式表と照合して底打ち直し =====
const CODE2NAME = { "01":"北海道","02":"青森県","03":"岩手県","04":"宮城県","05":"秋田県",/*…*/"47":"沖縄県" };

const NAME2CODE = {};
for (const [c,n] of Object.entries(CODE2NAME)) {
  NAME2CODE[n] = c;
  NAME2CODE[n.replace(/(県|府|都)$/,"")] = c; // 宮城/大阪/京都も拾う
}

const norm = s => String(s ?? "").trim();

function rebaselinePrefs(list){
  return list.map(p=>{
    let code = String(p.code).padStart(2,"0");
    let name = norm(p.name);

    // 名称からコードを優先補正
    const codeByName = NAME2CODE[name];
    if (codeByName && codeByName !== code) {
      console.warn(`補正: ${name} code ${code} -> ${codeByName}`);
      code = codeByName;
    }
    // 正式表記で上書き
    if (CODE2NAME[code]) name = CODE2NAME[code];

    return { ...p, code, name };
  });
}

const PREFS_BASE = rebaselinePrefs(PREFS);

  
// ===== タイル設定 =====
const TILE = 72;
const GAP  = 12;
const ORIGIN_X = 420;
const ORIGIN_Y = 60;

const HOKKAIDO_SCALE = 1.2; // ← ここは1回だけ
const HK_SHIFT_X = 930;      // 右へ
const HK_SHIFT_Y = 20;     // 上へ（マイナス）


// 値での色分け（必要なら入れる）
const values = {};

// クリック挙動（必要に応じて遷移に変更）
function onTileClick(pref){
  // location.href = `/docs/pref-${pref.code}.html`;
  alert(`${pref.name}（${pref.code}）`);
}

// SVG
const svg = document.getElementById('jp-tiles');

// —— viewBox 自動調整 用（ループ前） ——
const PAD = 60;
let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

// ===== 生成ロジック =====
  const code = String(p.code).padStart(2, '0');  // ← 追加（01〜47の文字列に統一）

  for (const p of PREFS_BASE) {
  const x = ORIGIN_X + (TILE + GAP) * p.col;
  const y = ORIGIN_Y + (TILE + GAP) * p.row;

  const scale = (p.code === "01") ? HOKKAIDO_SCALE : 1;

  // ★ 中央から拡大するぶん左右上下に半分ずつ広がる
  const delta = (TILE * (scale - 1)) / 2;
  minX = Math.min(minX, x - delta);
  minY = Math.min(minY, y - delta);
  maxX = Math.max(maxX, x + TILE + delta);
  maxY = Math.max(maxY, y + TILE + delta);

  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('id', `pref-${p.code}`);
  g.setAttribute('data-code', p.code);
  g.setAttribute('transform', `translate(${x},${y})`);
  g.setAttribute('role','group');
　g.setAttribute('data-name', p.name);

  g.setAttribute('data-name', p.name);
  // ★ 子g：右上シフト＋中央から1.2倍（北海道のみ）
  const s = document.createElementNS('http://www.w3.org/2000/svg','g');
  if (p.code === "01") {
    s.setAttribute(
      'transform',
      `translate(${TILE/2 + HK_SHIFT_X},${TILE/2 + HK_SHIFT_Y}) ` +
      `scale(${HOKKAIDO_SCALE}) ` +
      `translate(${-TILE/2},${-TILE/2})`
    );
  }

  const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
  rect.setAttribute('class','tile');
  rect.setAttribute('width', TILE);
  rect.setAttribute('height', TILE);
  rect.setAttribute('rx', 10);
  rect.setAttribute('ry', 10);
  rect.addEventListener('click', () => onTileClick(p));

  const label = document.createElementNS('http://www.w3.org/2000/svg','text');
  label.setAttribute('class','label');
  label.setAttribute('x', TILE/2);
  label.setAttribute('y', TILE/2);
  label.textContent = p.name;

  const code = document.createElementNS('http://www.w3.org/2000/svg','text');
  code.setAttribute('class','code');
  code.setAttribute('x', TILE/2);
  code.setAttribute('y', 6);
  code.textContent = p.code;

// ここは残す！ 描画の要
s.appendChild(rect);
s.appendChild(label);
s.appendChild(code);
g.appendChild(s);
// g.appendChild(title); ← これは入れない（標準ツールチップを無効化するため）
svg.appendChild(g);

 
  if (values[p.code] != null) {
    const v = values[p.code];
    const bucket = Math.max(1, Math.min(5, Math.ceil((v+1)/20)));
    g.classList.add(`v-${bucket}`);
  }

  svg.appendChild(g);
}


// —— ループ後に1回だけ：viewBox 自動調整 ——
const vbX = minX - PAD;
const vbY = minY - PAD;
const vbW = (maxX + TILE) - minX + PAD * 2;
const vbH = (maxY + TILE) - minY + PAD * 2;

svg.setAttribute('viewBox', `${vbX} ${vbY} ${vbW} ${vbH}`);
svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
// ===== ここから追記：3秒後に出る全国共通ツールチップ =====

// 1) ツールチップ用の要素を確保（無ければ生成）
let tooltip = document.getElementById('tooltip');
if (!tooltip) {
  tooltip = document.createElement('div');
  tooltip.id = 'tooltip';
  tooltip.hidden = true;
  document.body.appendChild(tooltip);
}

// 2) 最低限のスタイル（CSS未設置でも動くようJSで付与）
Object.assign(tooltip.style, {
  position: 'fixed',
  padding: '6px 10px',
  background: 'rgba(0,0,0,.85)',
  color: '#fff',
  borderRadius: '6px',
  fontSize: '14px',
  lineHeight: '1.2',
  pointerEvents: 'none',
  opacity: '0',
  transform: 'translateY(-6px)',
  transition: 'opacity .15s ease, transform .15s ease',
  zIndex: '9999',
});

let hoverTimer = null;

// 3) 県グループ（<g>）にリスナを付与
document.querySelectorAll('#jp-tiles > g').forEach(g => {
  const show = (x, y, text) => {
    tooltip.textContent = text || '';
    tooltip.style.left = (x + 12) + 'px';
    tooltip.style.top  = (y - 12) + 'px';
    tooltip.hidden = false;
    // アニメ風に少しだけ浮かせる
    requestAnimationFrame(() => {
      tooltip.style.opacity = '1';
      tooltip.style.transform = 'translateY(-10px)';
    });
  };

  const hide = () => {
    clearTimeout(hoverTimer);
    tooltip.style.opacity = '0';
    tooltip.style.transform = 'translateY(-6px)';
    // トランジション後に非表示
    setTimeout(() => { tooltip.hidden = true; }, 160);
  };

  g.addEventListener('mouseenter', e => {
    clearTimeout(hoverTimer);
    const label = g.getAttribute('data-name') || g.getAttribute('data-code') || '';
    // ★ ここが“3秒待ち”
    hoverTimer = setTimeout(() => show(e.clientX, e.clientY, label), 3000);
  });

  g.addEventListener('mousemove', e => {
    if (!tooltip.hidden) {
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top  = (e.clientY - 12) + 'px';
    }
  });

  g.addEventListener('mouseleave', hide);
  g.addEventListener('click', hide); // クリック時は即消す（クリック本体の動作はそのまま）
});

// ===== 追記ここまで =====

</script>

</body>
</html>
